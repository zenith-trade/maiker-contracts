# Performance Fee Implementation Guide

This document outlines the implementation details for performance fees in the Meteora DLMM Position Management protocol.

## Overview

Performance fees are charged on the profits generated by the strategy. The protocol uses a user-specific last share value tracking mechanism to ensure fair and accurate fee collection.

## Core Principles

1. **User-Specific Tracking**: Each user's performance is tracked individually based on their entry point
2. **Point-of-Interaction Collection**: Fees are collected when users deposit or withdraw
3. **Profit-Only Charging**: Fees are only charged on actual gains, not on recovering previous losses
4. **Capital-Efficient Fee Accrual**: Fee shares remain deployed in the strategy, continuing to earn returns until claimed

## Data Structures

### UserPosition
```rust
pub struct UserPosition {
    pub user: Pubkey,               // User's wallet address
    pub strategy: Pubkey,           // Reference to the StrategyConfig
    pub strategy_share: u64,        // User's share of the strategy position
    pub last_share_value: u64,      // Last share value when user deposited/withdrew
    pub last_update_timestamp: i64, // Last time the position was updated
    pub bump: u8,                   // PDA bump
}
```

### StrategyConfig (Fee-related fields)
```rust
pub struct StrategyConfig {
    // ... other fields ...
    pub strategy_shares: u64,       // Total shares issued
    pub fee_shares_pending: u64,    // Shares allocated to fees but not yet claimed
    // ... other fields ...
}
```

### GlobalConfig (Fee-related fields)
```rust
pub struct GlobalConfig {
    // ... other fields ...
    pub performance_fee_bps: u16,   // Performance fee in basis points (e.g., 2000 = 20%)
    pub withdrawal_fee_bps: u16,    // Optional withdrawal fee in basis points
    pub treasury: Pubkey,           // Address where fees are sent
}
```

## Performance Fee Calculation

### Mathematical Formulation

1. **Share Value Calculation**:
   Share Value = (Total Assets in Strategy) / (Total Strategy Shares)

2. **Performance Gain**:
   Performance Gain = Current Share Value - Last Share Value

3. **Fee Calculation**:
   Fee Percentage = Performance Fee BPS / 10000
   Fee Per Share = Performance Gain × Fee Percentage
   Total Fee Shares = (Fee Per Share × User Shares) / 1,000,000

4. **Token Amount Conversion**:
   Fee Token X = Total Fee Shares × Strategy Vault X Amount / Total Strategy Shares
   Fee Token Y = Total Fee Shares × Strategy Vault Y Amount / Total Strategy Shares

5. **Updated User Shares**:
   User Shares After Fee = User Shares - Total Fee Shares

### Implementation Flow

#### 1. Deposit Handler

When a user deposits, we:
- Calculate the current share value
- For existing users, collect performance fees if the current share value exceeds their last recorded share value
- Calculate new shares for this deposit
- Update the user's position with new shares and the current share value as their new reference point

#### 2. Withdraw Handler

When a user withdraws, we:
- Calculate the current share value
- Collect performance fees if the current share value exceeds their last recorded share value
- Calculate new shares for this deposit 
- Calculate token amounts to return to user based on their remaining shares
- Apply any withdrawal fee if configured
- Update the user's position with new shares and the current share value as their new reference point

## Fee Accrual and Claiming Process

Our performance fee implementation uses a two-phase approach that maximizes capital efficiency:

### Phase 1: Fee Accrual

When performance fees are collected during user deposits or withdrawals:

1. The fee amount is calculated in shares based on the user's performance gain
2. These shares are deducted from the user's position
3. Instead of immediately withdrawing tokens, the shares are tracked in `fee_shares_pending`
4. The total strategy shares remain unchanged
5. The fee shares continue to be deployed in the strategy, earning returns

This approach has several advantages:
- **Capital Efficiency**: Fee shares remain productive, continuing to generate returns
- **Reduced Gas Costs**: No token transfers are needed at the time of fee collection
- **Compounding Returns**: Fees themselves earn returns until claimed
- **Flexible Treasury Management**: The admin can decide when to claim fees based on market conditions

### Phase 2: Fee Claiming

When the admin decides to claim fees:

1. The admin calls the `claim_fees` instruction, optionally specifying how many shares to claim
2. The corresponding token amounts are calculated based on the current share value
3. Tokens are transferred from the strategy vaults to the treasury
4. The `fee_shares_pending` and `strategy_shares` are reduced accordingly

This two-phase approach allows for:
- **Flexible Claiming**: Fees can be claimed in full or in portions
- **Strategic Timing**: Fees can be claimed during favorable market conditions
- **Reduced Transaction Frequency**: Fees can be accumulated and claimed in batches

## Practical Example

Let's walk through a concrete example:

1. **Initial deposit**:
   - User A deposits 100 SOL and 5,000 USDC
   - Initial share value: 1.0 (fixed)
   - User A receives 5,100 shares
   - User A's last_share_value = 1.0

2. **Strategy performs well**:
   - After trading, strategy value increases by 10%
   - New share value: 1.1
   - No fees collected yet (no user interaction)

3. **User B deposits**:
   - User B deposits 50 SOL and 2,500 USDC
   - Current share value: 1.1
   - User B receives 2,500 / 1.1 = 2,272.73 shares
   - User B's last_share_value = 1.1

4. **Strategy continues to perform well**:
   - Share value increases to 1.2

5. **User A deposits again**:
   - Current share value: 1.2
   - Performance gain: 1.2 - 1.0 = 0.2 per share
   - With 20% performance fee: 0.2 * 0.2 = 0.04 fee per share
   - Total fee shares: 0.04 * 5,100 / 1.0 = 204 shares
   - User A now has 5,100 - 204 = 4,896 shares
   - User A's last_share_value is updated to 1.2
   - User A's new deposit is calculated based on the 1.2 share value
   - The 204 fee shares are added to fee_shares_pending but remain deployed in the strategy

6. **User B withdraws**:
   - Current share value: 1.2
   - Performance gain: 1.2 - 1.1 = 0.1 per share
   - With 20% performance fee: 0.1 * 0.2 = 0.02 fee per share
   - Total fee shares: 0.02 * 2,272.73 / 1.0 = 45.45 shares
   - User B receives tokens for 2,272.73 - 45.45 = 2,227.28 shares
   - The 45.45 fee shares are added to fee_shares_pending but remain deployed in the strategy

7. **Admin claims fees**:
   - Total fee_shares_pending: 204 + 45.45 = 249.45 shares
   - Current strategy holdings: 130 SOL and 5,400 USDC
   - Total strategy shares: 7,168.73 (4,896 + 2,272.73)
   - Fee token X: 249.45 * 130 / 7,168.73 = 4.52 SOL
   - Fee token Y: 249.45 * 5,400 / 7,168.73 = 187.89 USDC
   - These tokens are transferred to the treasury
   - fee_shares_pending is reduced to 0
   - strategy_shares is reduced to 6,919.28 (7,168.73 - 249.45)

## Why Periodic Fee Collection Is Important

While the point-of-interaction fee collection works well for active users, it creates an imbalance for long-term passive holders:

1. **Autocompounding Advantage**: Users who don't deposit or withdraw benefit from autocompounding their gains without paying performance fees, effectively getting an interest-free loan of the performance fee amount.

2. **Fee Deferral**: Long-term holders can defer performance fees indefinitely, creating an unfair advantage over users who interact more frequently with the protocol.

3. **Treasury Cash Flow**: The protocol treasury receives fees irregularly, making financial planning difficult.

4. **Accurate Performance Tracking**: Periodic fee collection ensures the strategy's performance metrics accurately reflect net-of-fee returns.

### Implementing Periodic Fee Collection

A periodic fee collection mechanism would:

1. Iterate through all user positions
2. Calculate current share value
3. For each user, compare current share value to their last_share_value
4. Collect fees on gains and update last_share_value
5. Adjust user shares accordingly

This ensures all users pay fees fairly based on the same schedule, regardless of their interaction frequency.

## Implementation Considerations

1. **Fixed-Point Math**: All calculations use fixed-point arithmetic with 6 decimal places to ensure precision without floating point.

2. **Gas Efficiency**: Fee collection is integrated with deposit/withdraw to minimize gas costs.

3. **Precision**: Share calculations must handle rounding carefully to prevent value leakage.

4. **Edge Cases**:
   - First deposit (initialize last_share_value)
   - Complete withdrawals (closing user positions)
   - Share value decreases (no fees collected)

5. **Testing**: Thoroughly test with various market scenarios to ensure correct fee calculation.

6. **Transparency**: Emit detailed events for all fee-related operations to maintain transparency.

## Conclusion

This user-specific last share value approach provides a fair and efficient mechanism for performance fee collection. It ensures fees are only charged on actual gains and are calculated accurately based on each user's entry point. The two-phase fee accrual and claiming process maximizes capital efficiency by keeping fee shares deployed in the strategy until they're claimed.

Adding periodic fee collection in the future will further enhance fairness by ensuring all users pay fees on the same schedule, regardless of their interaction patterns. 

