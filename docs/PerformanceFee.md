# Performance Fee Implementation Guide

This document outlines the implementation details for performance fees in the Meteora DLMM Position Management protocol.

## Overview

Performance fees are charged on the profits generated by the strategy. The protocol uses a high water mark (HWM) mechanism to ensure fees are only charged on new profits, not on recovering previous losses.

## High Water Mark Explained

The high water mark is the highest value per share that a strategy has achieved. Performance fees are only charged on increases above this mark. This ensures:

1. Fees are only charged on new profits
2. Users don't pay fees twice for the same performance
3. The protocol must recover any losses before charging new fees

## Data Structures

### PerformanceMetrics    pub struct PerformanceMetrics {
        pub strategy: Pubkey,                // Strategy this metrics belongs to
        pub high_water_mark: u64,            // Highest value per share (fixed-point)
        pub last_fee_collection_timestamp: i64, // Last time fees were collected
        pub total_fees_collected_x: u64,     // Total token X fees collected
        pub total_fees_collected_y: u64,     // Total token Y fees collected
    }

### GlobalConfig (Fee-related fields)

    pub struct GlobalConfig {
        // ... other fields ...
        pub performance_fee_bps: u16,        // Performance fee in basis points (e.g., 2000 = 20%)
        pub withdrawal_fee_bps: u16,         // Optional withdrawal fee in basis points
        pub treasury: Pubkey,                // Address where fees are sent
        pub high_water_mark_enabled: bool,   // Whether to use high-water mark
    }

## Performance Fee Calculation Flow

### 1. Initial Setup

When a strategy is created:
- Set initial value per share = 1.0 (or another base value, using fixed-point representation)
- Set initial high water mark = initial value per share
- Create PerformanceMetrics account for the strategy

### 2. Regular Performance Fee Collection

This happens during rebalancing or at scheduled intervals:

    fn collect_performance_fees(
        strategy: &mut StrategyConfig,
        performance_metrics: &mut PerformanceMetrics,
        global_config: &GlobalConfig,
    ) -> Result<()> {
        // 1. Calculate current value per share
        let total_value_x = strategy.x_vault_balance + position_x_equivalent;
        let total_value_y = strategy.y_vault_balance + position_y_equivalent;
        let total_value = total_value_x + total_value_y;
        
        // Using fixed-point math with 6 decimals
        let current_value_per_share = (total_value * 1_000_000) / strategy.strategy_shares;
        
        // 2. Check if we're above high water mark
        if current_value_per_share <= performance_metrics.high_water_mark {
            // No new profits, no fees to collect
            return Ok(());
        }
        
        // 3. Calculate performance gain
        let performance_gain = current_value_per_share - performance_metrics.high_water_mark;
        
        // 4. Calculate fee amount
        let performance_fee_per_share = performance_gain * global_config.performance_fee_bps / 10_000;
        let total_performance_fee = performance_fee_per_share * strategy.strategy_shares / 1_000_000;
        
        // 5. Convert fee to token amounts (proportional to current holdings)
        let fee_in_token_x = total_performance_fee * total_value_x / total_value;
        let fee_in_token_y = total_performance_fee * total_value_y / total_value;
        
        // 6. Transfer fees to treasury
        transfer_tokens(strategy.x_vault, global_config.treasury, fee_in_token_x)?;
        transfer_tokens(strategy.y_vault, global_config.treasury, fee_in_token_y)?;
        
        // 7. Update performance metrics
        performance_metrics.high_water_mark = current_value_per_share;
        performance_metrics.last_fee_collection_timestamp = Clock::get()?.unix_timestamp;
        performance_metrics.total_fees_collected_x += fee_in_token_x;
        performance_metrics.total_fees_collected_y += fee_in_token_y;
        
        // 8. Emit event
        emit!(PerformanceFeeCollected {
            strategy: strategy.key(),
            fee_in_token_x,
            fee_in_token_y,
            current_value_per_share,
        });
        
        Ok(())
    }

### 3. Fee Collection During Withdrawals

When a user withdraws, ensure they pay their share of accrued performance fees:

    fn withdraw_with_performance_fee(
        user: &Pubkey,
        strategy: &mut StrategyConfig,
        user_position: &mut UserPosition,
        performance_metrics: &mut PerformanceMetrics,
        global_config: &GlobalConfig,
        amount_shares: u64,
    ) -> Result<()> {
        // 1. Collect any pending performance fees first
        collect_performance_fees(strategy, performance_metrics, global_config)?;
        
        // 2. Calculate user's share value
        let total_value = strategy.x_vault_balance + strategy.y_vault_balance;
        let user_share_value = amount_shares * total_value / strategy.strategy_shares;
        
        // 3. Apply withdrawal fee if configured
        let mut withdrawal_fee_x = 0;
        let mut withdrawal_fee_y = 0;
        
        if global_config.withdrawal_fee_bps > 0 {
            let withdrawal_fee = user_share_value * global_config.withdrawal_fee_bps / 10_000;
            
            // Calculate proportional amounts of X and Y
            withdrawal_fee_x = withdrawal_fee * strategy.x_vault_balance / total_value;
            withdrawal_fee_y = withdrawal_fee * strategy.y_vault_balance / total_value;
            
            // Transfer withdrawal fees to treasury
            transfer_tokens(strategy.x_vault, global_config.treasury, withdrawal_fee_x)?;
            transfer_tokens(strategy.y_vault, global_config.treasury, withdrawal_fee_y)?;
        }
        
        // 4. Calculate tokens to return to user
        let user_token_x = amount_shares * strategy.x_vault_balance / strategy.strategy_shares - withdrawal_fee_x;
        let user_token_y = amount_shares * strategy.y_vault_balance / strategy.strategy_shares - withdrawal_fee_y;
        
        // 5. Update user position and strategy
        user_position.strategy_share -= amount_shares;
        strategy.strategy_shares -= amount_shares;
        
        // 6. Transfer tokens to user
        transfer_tokens(strategy.x_vault, user, user_token_x)?;
        transfer_tokens(strategy.y_vault, user, user_token_y)?;
        
        // 7. Emit event
        emit!(UserWithdrew {
            user: *user,
            strategy: strategy.key(),
            shares_amount: amount_shares,
            token_x_amount: user_token_x,
            token_y_amount: user_token_y,
        });
        
        Ok(())
    }

### 4. Handling Deposits

When a user deposits, they receive shares at the current value per share:

    fn deposit(
        user: &Pubkey,
        strategy: &mut StrategyConfig,
        user_position: &mut UserPosition,
        performance_metrics: &mut PerformanceMetrics,
        global_config: &GlobalConfig,
        amount_x: u64,
        amount_y: u64,
    ) -> Result<()> {
        // 1. Collect any pending performance fees first
        collect_performance_fees(strategy, performance_metrics, global_config)?;
        
        // 2. Calculate current value per share
        let total_value_before = strategy.x_vault_balance + strategy.y_vault_balance;
        let current_value_per_share = if strategy.strategy_shares == 0 {
            // Initial deposit case
            1_000_000 // Fixed-point representation of 1.0
        } else {
            (total_value_before * 1_000_000) / strategy.strategy_shares
        };
        
        // 3. Calculate shares to mint
        let deposit_value = amount_x + amount_y; // Simplified; might need price-aware calculation
        let new_shares = (deposit_value * 1_000_000) / current_value_per_share;
        
        // 4. Update user position and strategy
        user_position.strategy_share += new_shares;
        strategy.strategy_shares += new_shares;
        
        // 5. Transfer tokens to vaults
        transfer_tokens(user, strategy.x_vault, amount_x)?;
        transfer_tokens(user, strategy.y_vault, amount_y)?;
        
        // 6. Update user position metadata
        user_position.last_update_timestamp = Clock::get()?.unix_timestamp;
        if user_position.deposit_timestamp == 0 {
            user_position.deposit_timestamp = user_position.last_update_timestamp;
        }
        
        // 7. Emit event
        emit!(UserDeposited {
            user: *user,
            strategy: strategy.key(),
            shares_amount: new_shares,
            token_x_amount: amount_x,
            token_y_amount: amount_y,
        });
        
        Ok(())
    }

## Practical Example

Let's walk through a concrete example:

1. **Initial state**:
   - Strategy has 100 SOL and 5,000 USDC
   - Total shares: 10,000
   - Value per share: (100 + 5,000) / 10,000 = 0.51 (simplified)
   - High water mark: 0.51

2. **Strategy performs well**:
   - After trading, strategy now has 120 SOL and 5,200 USDC
   - New value per share: (120 + 5,200) / 10,000 = 0.532
   - Performance gain: 0.532 - 0.51 = 0.022 per share
   - With 20% performance fee: 0.022 * 0.2 = 0.0044 fee per share
   - Total fee: 0.0044 * 10,000 = 44 value units
   - New high water mark: 0.532

3. **Strategy loses value**:
   - After market downturn, strategy has 110 SOL and 5,100 USDC
   - New value per share: (110 + 5,100) / 10,000 = 0.521
   - This is below the high water mark of 0.532
   - No performance fee is charged

4. **Strategy recovers**:
   - Strategy recovers to 125 SOL and 5,300 USDC
   - New value per share: (125 + 5,300) / 10,000 = 0.5425
   - This is above the high water mark of 0.532
   - Performance gain: 0.5425 - 0.532 = 0.0105 per share
   - Performance fee: 0.0105 * 0.2 * 10,000 = 21 value units
   - New high water mark: 0.5425

## Implementation Considerations

1. **Fixed-Point Math**: Use fixed-point arithmetic for precise calculations without floating point.

2. **Gas Efficiency**: Batch fee collections with other operations to amortize gas costs.

3. **Collection Frequency**: Balance between accuracy (frequent collection) and gas costs.

4. **Token Valuation**: Consider using price oracles for more accurate token valuation.

5. **Transparency**: Emit detailed events for all fee-related operations.

6. **Edge Cases**:
   - Handle the first deposit properly (initialize high water mark)
   - Handle complete withdrawals (closing user positions)
   - Handle emergency situations (pausing fee collection)

7. **Testing**: Thoroughly test with various market scenarios to ensure correct fee calculation. 

