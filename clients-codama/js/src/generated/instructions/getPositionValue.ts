/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, type Address, type Codec, type Decoder, type Encoder, type IAccountMeta, type IAccountSignerMeta, type IInstruction, type IInstructionWithAccounts, type IInstructionWithData, type ReadonlyAccount, type ReadonlySignerAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount } from '@solana/kit';
import { MAIKER_CONTRACTS_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const GET_POSITION_VALUE_DISCRIMINATOR = new Uint8Array([176, 101, 36, 67, 215, 72, 215, 247]);

export function getGetPositionValueDiscriminatorBytes() { return fixEncoderSize(getBytesEncoder(), 8).encode(GET_POSITION_VALUE_DISCRIMINATOR); }

export type GetPositionValueInstruction<
  TProgram extends string = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS,
      TAccountStrategy extends string | IAccountMeta<string> = string, TAccountPosition extends string | IAccountMeta<string> = string, TAccountLbPair extends string | IAccountMeta<string> = string, TAccountBinArrayLower extends string | IAccountMeta<string> = string, TAccountBinArrayUpper extends string | IAccountMeta<string> = string, TAccountUser extends string | IAccountMeta<string> = string,
    TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram>
      & IInstructionWithData<Uint8Array>
        & IInstructionWithAccounts<[TAccountStrategy extends string ? WritableAccount<TAccountStrategy> : TAccountStrategy, TAccountPosition extends string ? ReadonlyAccount<TAccountPosition> : TAccountPosition, TAccountLbPair extends string ? ReadonlyAccount<TAccountLbPair> : TAccountLbPair, TAccountBinArrayLower extends string ? ReadonlyAccount<TAccountBinArrayLower> : TAccountBinArrayLower, TAccountBinArrayUpper extends string ? ReadonlyAccount<TAccountBinArrayUpper> : TAccountBinArrayUpper, TAccountUser extends string ? ReadonlySignerAccount<TAccountUser> & IAccountSignerMeta<TAccountUser> : TAccountUser, ...TRemainingAccounts]>
  ;



export type GetPositionValueInstructionData = { discriminator: ReadonlyUint8Array;  };

export type GetPositionValueInstructionDataArgs = {  };




export function getGetPositionValueInstructionDataEncoder(): Encoder<GetPositionValueInstructionDataArgs> {
  return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: GET_POSITION_VALUE_DISCRIMINATOR }));
}



export function getGetPositionValueInstructionDataDecoder(): Decoder<GetPositionValueInstructionData> {
  return getStructDecoder([['discriminator', fixDecoderSize(getBytesDecoder(), 8)]]);
}




export function getGetPositionValueInstructionDataCodec(): Codec<GetPositionValueInstructionDataArgs, GetPositionValueInstructionData> {
  return combineCodec(getGetPositionValueInstructionDataEncoder(), getGetPositionValueInstructionDataDecoder());
}




export type GetPositionValueInput<TAccountStrategy extends string = string,
  TAccountPosition extends string = string,
  TAccountLbPair extends string = string,
  TAccountBinArrayLower extends string = string,
  TAccountBinArrayUpper extends string = string,
  TAccountUser extends string = string,
  >
=  {
  strategy: Address<TAccountStrategy>;
position: Address<TAccountPosition>;
lbPair: Address<TAccountLbPair>;
binArrayLower: Address<TAccountBinArrayLower>;
binArrayUpper: Address<TAccountBinArrayUpper>;
user: TransactionSigner<TAccountUser>;
}


export  function getGetPositionValueInstruction<TAccountStrategy extends string, TAccountPosition extends string, TAccountLbPair extends string, TAccountBinArrayLower extends string, TAccountBinArrayUpper extends string, TAccountUser extends string, TProgramAddress extends Address = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS>(input: GetPositionValueInput<TAccountStrategy, TAccountPosition, TAccountLbPair, TAccountBinArrayLower, TAccountBinArrayUpper, TAccountUser>, config?: { programAddress?: TProgramAddress } ): GetPositionValueInstruction<TProgramAddress, TAccountStrategy, TAccountPosition, TAccountLbPair, TAccountBinArrayLower, TAccountBinArrayUpper, TAccountUser> {
  // Program address.
  const programAddress = config?.programAddress ?? MAIKER_CONTRACTS_PROGRAM_ADDRESS;

      // Original accounts.
    const originalAccounts = {
              strategy: { value: input.strategy ?? null, isWritable: true },
              position: { value: input.position ?? null, isWritable: false },
              lbPair: { value: input.lbPair ?? null, isWritable: false },
              binArrayLower: { value: input.binArrayLower ?? null, isWritable: false },
              binArrayUpper: { value: input.binArrayUpper ?? null, isWritable: false },
              user: { value: input.user ?? null, isWritable: false },
          };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;
  
  
  
  





      const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {accounts: [
                  getAccountMeta(accounts.strategy),
                  getAccountMeta(accounts.position),
                  getAccountMeta(accounts.lbPair),
                  getAccountMeta(accounts.binArrayLower),
                  getAccountMeta(accounts.binArrayUpper),
                  getAccountMeta(accounts.user),
                      ]      ,    programAddress,
          data: getGetPositionValueInstructionDataEncoder().encode({}),
      } as GetPositionValueInstruction<TProgramAddress, TAccountStrategy, TAccountPosition, TAccountLbPair, TAccountBinArrayLower, TAccountBinArrayUpper, TAccountUser>;

      return instruction;
  }


export type ParsedGetPositionValueInstruction<
  TProgram extends string = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS,
      TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
  > = {
  programAddress: Address<TProgram>;
      accounts: {
                      strategy: TAccountMetas[0],
                      position: TAccountMetas[1],
                      lbPair: TAccountMetas[2],
                      binArrayLower: TAccountMetas[3],
                      binArrayUpper: TAccountMetas[4],
                      user: TAccountMetas[5],
          };
        data: GetPositionValueInstructionData;
  };

export function parseGetPositionValueInstruction<
  TProgram extends string,
      TAccountMetas extends readonly IAccountMeta[],
  >(
  instruction: IInstruction<TProgram>
          & IInstructionWithAccounts<TAccountMetas>
              & IInstructionWithData<Uint8Array>
    ): ParsedGetPositionValueInstruction<TProgram , TAccountMetas> {
      if (instruction.accounts.length < 6) {
      // TODO: Coded error.
      throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
      const accountMeta = instruction.accounts![accountIndex]!;
      accountIndex += 1;
      return accountMeta;
    }
        return {
    programAddress: instruction.programAddress,
          accounts: {
                              strategy: getNextAccount(),
                                        position: getNextAccount(),
                                        lbPair: getNextAccount(),
                                        binArrayLower: getNextAccount(),
                                        binArrayUpper: getNextAccount(),
                                        user: getNextAccount(),
                        },
              data: getGetPositionValueInstructionDataDecoder().decode(instruction.data),
      };
}

