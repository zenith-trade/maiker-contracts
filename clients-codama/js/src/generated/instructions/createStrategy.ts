/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, transformEncoder, type Address, type Codec, type Decoder, type Encoder, type IAccountMeta, type IAccountSignerMeta, type IInstruction, type IInstructionWithAccounts, type IInstructionWithData, type ReadonlyAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount, type WritableSignerAccount } from '@solana/kit';
import { MAIKER_CONTRACTS_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const CREATE_STRATEGY_DISCRIMINATOR = new Uint8Array([152, 160, 107, 148, 245, 190, 127, 224]);

export function getCreateStrategyDiscriminatorBytes() { return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_STRATEGY_DISCRIMINATOR); }

export type CreateStrategyInstruction<
  TProgram extends string = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS,
      TAccountCreator extends string | IAccountMeta<string> = string, TAccountXMint extends string | IAccountMeta<string> = string, TAccountYMint extends string | IAccountMeta<string> = string, TAccountXVault extends string | IAccountMeta<string> = string, TAccountYVault extends string | IAccountMeta<string> = string, TAccountStrategy extends string | IAccountMeta<string> = string, TAccountTokenProgram extends string | IAccountMeta<string> = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", TAccountAssociatedTokenProgram extends string | IAccountMeta<string> = string, TAccountSystemProgram extends string | IAccountMeta<string> = "11111111111111111111111111111111",
    TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram>
      & IInstructionWithData<Uint8Array>
        & IInstructionWithAccounts<[TAccountCreator extends string ? WritableSignerAccount<TAccountCreator> & IAccountSignerMeta<TAccountCreator> : TAccountCreator, TAccountXMint extends string ? ReadonlyAccount<TAccountXMint> : TAccountXMint, TAccountYMint extends string ? ReadonlyAccount<TAccountYMint> : TAccountYMint, TAccountXVault extends string ? ReadonlyAccount<TAccountXVault> : TAccountXVault, TAccountYVault extends string ? ReadonlyAccount<TAccountYVault> : TAccountYVault, TAccountStrategy extends string ? WritableAccount<TAccountStrategy> : TAccountStrategy, TAccountTokenProgram extends string ? ReadonlyAccount<TAccountTokenProgram> : TAccountTokenProgram, TAccountAssociatedTokenProgram extends string ? ReadonlyAccount<TAccountAssociatedTokenProgram> : TAccountAssociatedTokenProgram, TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram, ...TRemainingAccounts]>
  ;



export type CreateStrategyInstructionData = { discriminator: ReadonlyUint8Array;  };

export type CreateStrategyInstructionDataArgs = {  };




export function getCreateStrategyInstructionDataEncoder(): Encoder<CreateStrategyInstructionDataArgs> {
  return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)]]), (value) => ({ ...value, discriminator: CREATE_STRATEGY_DISCRIMINATOR }));
}



export function getCreateStrategyInstructionDataDecoder(): Decoder<CreateStrategyInstructionData> {
  return getStructDecoder([['discriminator', fixDecoderSize(getBytesDecoder(), 8)]]);
}




export function getCreateStrategyInstructionDataCodec(): Codec<CreateStrategyInstructionDataArgs, CreateStrategyInstructionData> {
  return combineCodec(getCreateStrategyInstructionDataEncoder(), getCreateStrategyInstructionDataDecoder());
}




export type CreateStrategyInput<TAccountCreator extends string = string,
  TAccountXMint extends string = string,
  TAccountYMint extends string = string,
  TAccountXVault extends string = string,
  TAccountYVault extends string = string,
  TAccountStrategy extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountAssociatedTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  >
=  {
  creator: TransactionSigner<TAccountCreator>;
xMint: Address<TAccountXMint>;
yMint: Address<TAccountYMint>;
xVault: Address<TAccountXVault>;
yVault: Address<TAccountYVault>;
strategy: Address<TAccountStrategy>;
tokenProgram?: Address<TAccountTokenProgram>;
associatedTokenProgram: Address<TAccountAssociatedTokenProgram>;
systemProgram?: Address<TAccountSystemProgram>;
}


export  function getCreateStrategyInstruction<TAccountCreator extends string, TAccountXMint extends string, TAccountYMint extends string, TAccountXVault extends string, TAccountYVault extends string, TAccountStrategy extends string, TAccountTokenProgram extends string, TAccountAssociatedTokenProgram extends string, TAccountSystemProgram extends string, TProgramAddress extends Address = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS>(input: CreateStrategyInput<TAccountCreator, TAccountXMint, TAccountYMint, TAccountXVault, TAccountYVault, TAccountStrategy, TAccountTokenProgram, TAccountAssociatedTokenProgram, TAccountSystemProgram>, config?: { programAddress?: TProgramAddress } ): CreateStrategyInstruction<TProgramAddress, TAccountCreator, TAccountXMint, TAccountYMint, TAccountXVault, TAccountYVault, TAccountStrategy, TAccountTokenProgram, TAccountAssociatedTokenProgram, TAccountSystemProgram> {
  // Program address.
  const programAddress = config?.programAddress ?? MAIKER_CONTRACTS_PROGRAM_ADDRESS;

      // Original accounts.
    const originalAccounts = {
              creator: { value: input.creator ?? null, isWritable: true },
              xMint: { value: input.xMint ?? null, isWritable: false },
              yMint: { value: input.yMint ?? null, isWritable: false },
              xVault: { value: input.xVault ?? null, isWritable: false },
              yVault: { value: input.yVault ?? null, isWritable: false },
              strategy: { value: input.strategy ?? null, isWritable: true },
              tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
              associatedTokenProgram: { value: input.associatedTokenProgram ?? null, isWritable: false },
              systemProgram: { value: input.systemProgram ?? null, isWritable: false },
          };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;
  
  
  
  // Resolve default values.
if (!accounts.tokenProgram.value) {
accounts.tokenProgram.value = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
}
if (!accounts.systemProgram.value) {
accounts.systemProgram.value = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
}





      const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {accounts: [
                  getAccountMeta(accounts.creator),
                  getAccountMeta(accounts.xMint),
                  getAccountMeta(accounts.yMint),
                  getAccountMeta(accounts.xVault),
                  getAccountMeta(accounts.yVault),
                  getAccountMeta(accounts.strategy),
                  getAccountMeta(accounts.tokenProgram),
                  getAccountMeta(accounts.associatedTokenProgram),
                  getAccountMeta(accounts.systemProgram),
                      ]      ,    programAddress,
          data: getCreateStrategyInstructionDataEncoder().encode({}),
      } as CreateStrategyInstruction<TProgramAddress, TAccountCreator, TAccountXMint, TAccountYMint, TAccountXVault, TAccountYVault, TAccountStrategy, TAccountTokenProgram, TAccountAssociatedTokenProgram, TAccountSystemProgram>;

      return instruction;
  }


export type ParsedCreateStrategyInstruction<
  TProgram extends string = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS,
      TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
  > = {
  programAddress: Address<TProgram>;
      accounts: {
                      creator: TAccountMetas[0],
                      xMint: TAccountMetas[1],
                      yMint: TAccountMetas[2],
                      xVault: TAccountMetas[3],
                      yVault: TAccountMetas[4],
                      strategy: TAccountMetas[5],
                      tokenProgram: TAccountMetas[6],
                      associatedTokenProgram: TAccountMetas[7],
                      systemProgram: TAccountMetas[8],
          };
        data: CreateStrategyInstructionData;
  };

export function parseCreateStrategyInstruction<
  TProgram extends string,
      TAccountMetas extends readonly IAccountMeta[],
  >(
  instruction: IInstruction<TProgram>
          & IInstructionWithAccounts<TAccountMetas>
              & IInstructionWithData<Uint8Array>
    ): ParsedCreateStrategyInstruction<TProgram , TAccountMetas> {
      if (instruction.accounts.length < 9) {
      // TODO: Coded error.
      throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
      const accountMeta = instruction.accounts![accountIndex]!;
      accountIndex += 1;
      return accountMeta;
    }
        return {
    programAddress: instruction.programAddress,
          accounts: {
                              creator: getNextAccount(),
                                        xMint: getNextAccount(),
                                        yMint: getNextAccount(),
                                        xVault: getNextAccount(),
                                        yVault: getNextAccount(),
                                        strategy: getNextAccount(),
                                        tokenProgram: getNextAccount(),
                                        associatedTokenProgram: getNextAccount(),
                                        systemProgram: getNextAccount(),
                        },
              data: getCreateStrategyInstructionDataDecoder().decode(instruction.data),
      };
}

