/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, fixDecoderSize, fixEncoderSize, getBytesDecoder, getBytesEncoder, getI32Decoder, getI32Encoder, getStructDecoder, getStructEncoder, transformEncoder, type Address, type Codec, type Decoder, type Encoder, type IAccountMeta, type IAccountSignerMeta, type IInstruction, type IInstructionWithAccounts, type IInstructionWithData, type ReadonlyAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount, type WritableSignerAccount } from '@solana/kit';
import { MAIKER_CONTRACTS_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const INITIALIZE_POSITION_DISCRIMINATOR = new Uint8Array([219, 192, 234, 71, 190, 191, 102, 80]);

export function getInitializePositionDiscriminatorBytes() { return fixEncoderSize(getBytesEncoder(), 8).encode(INITIALIZE_POSITION_DISCRIMINATOR); }

export type InitializePositionInstruction<
  TProgram extends string = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS,
      TAccountAuthority extends string | IAccountMeta<string> = string, TAccountGlobalConfig extends string | IAccountMeta<string> = string, TAccountStrategy extends string | IAccountMeta<string> = string, TAccountPosition extends string | IAccountMeta<string> = string, TAccountLbPair extends string | IAccountMeta<string> = string, TAccountLbClmmProgram extends string | IAccountMeta<string> = string, TAccountEventAuthority extends string | IAccountMeta<string> = string, TAccountSystemProgram extends string | IAccountMeta<string> = "11111111111111111111111111111111", TAccountRent extends string | IAccountMeta<string> = "SysvarRent111111111111111111111111111111111",
    TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram>
      & IInstructionWithData<Uint8Array>
        & IInstructionWithAccounts<[TAccountAuthority extends string ? WritableSignerAccount<TAccountAuthority> & IAccountSignerMeta<TAccountAuthority> : TAccountAuthority, TAccountGlobalConfig extends string ? ReadonlyAccount<TAccountGlobalConfig> : TAccountGlobalConfig, TAccountStrategy extends string ? WritableAccount<TAccountStrategy> : TAccountStrategy, TAccountPosition extends string ? WritableSignerAccount<TAccountPosition> & IAccountSignerMeta<TAccountPosition> : TAccountPosition, TAccountLbPair extends string ? ReadonlyAccount<TAccountLbPair> : TAccountLbPair, TAccountLbClmmProgram extends string ? ReadonlyAccount<TAccountLbClmmProgram> : TAccountLbClmmProgram, TAccountEventAuthority extends string ? ReadonlyAccount<TAccountEventAuthority> : TAccountEventAuthority, TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram, TAccountRent extends string ? ReadonlyAccount<TAccountRent> : TAccountRent, ...TRemainingAccounts]>
  ;



export type InitializePositionInstructionData = { discriminator: ReadonlyUint8Array; lowerBinId: number; width: number;  };

export type InitializePositionInstructionDataArgs = { lowerBinId: number; width: number;  };




export function getInitializePositionInstructionDataEncoder(): Encoder<InitializePositionInstructionDataArgs> {
  return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)], ['lowerBinId', getI32Encoder()], ['width', getI32Encoder()]]), (value) => ({ ...value, discriminator: INITIALIZE_POSITION_DISCRIMINATOR }));
}



export function getInitializePositionInstructionDataDecoder(): Decoder<InitializePositionInstructionData> {
  return getStructDecoder([['discriminator', fixDecoderSize(getBytesDecoder(), 8)], ['lowerBinId', getI32Decoder()], ['width', getI32Decoder()]]);
}




export function getInitializePositionInstructionDataCodec(): Codec<InitializePositionInstructionDataArgs, InitializePositionInstructionData> {
  return combineCodec(getInitializePositionInstructionDataEncoder(), getInitializePositionInstructionDataDecoder());
}




export type InitializePositionInput<TAccountAuthority extends string = string,
  TAccountGlobalConfig extends string = string,
  TAccountStrategy extends string = string,
  TAccountPosition extends string = string,
  TAccountLbPair extends string = string,
  TAccountLbClmmProgram extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountRent extends string = string,
  >
=  {
  authority: TransactionSigner<TAccountAuthority>;
globalConfig: Address<TAccountGlobalConfig>;
strategy: Address<TAccountStrategy>;
position: TransactionSigner<TAccountPosition>;
lbPair: Address<TAccountLbPair>;
/** The lb_clmm program */
lbClmmProgram: Address<TAccountLbClmmProgram>;
eventAuthority: Address<TAccountEventAuthority>;
systemProgram?: Address<TAccountSystemProgram>;
rent?: Address<TAccountRent>;lowerBinId: InitializePositionInstructionDataArgs["lowerBinId"];
width: InitializePositionInstructionDataArgs["width"];
}


export  function getInitializePositionInstruction<TAccountAuthority extends string, TAccountGlobalConfig extends string, TAccountStrategy extends string, TAccountPosition extends string, TAccountLbPair extends string, TAccountLbClmmProgram extends string, TAccountEventAuthority extends string, TAccountSystemProgram extends string, TAccountRent extends string, TProgramAddress extends Address = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS>(input: InitializePositionInput<TAccountAuthority, TAccountGlobalConfig, TAccountStrategy, TAccountPosition, TAccountLbPair, TAccountLbClmmProgram, TAccountEventAuthority, TAccountSystemProgram, TAccountRent>, config?: { programAddress?: TProgramAddress } ): InitializePositionInstruction<TProgramAddress, TAccountAuthority, TAccountGlobalConfig, TAccountStrategy, TAccountPosition, TAccountLbPair, TAccountLbClmmProgram, TAccountEventAuthority, TAccountSystemProgram, TAccountRent> {
  // Program address.
  const programAddress = config?.programAddress ?? MAIKER_CONTRACTS_PROGRAM_ADDRESS;

      // Original accounts.
    const originalAccounts = {
              authority: { value: input.authority ?? null, isWritable: true },
              globalConfig: { value: input.globalConfig ?? null, isWritable: false },
              strategy: { value: input.strategy ?? null, isWritable: true },
              position: { value: input.position ?? null, isWritable: true },
              lbPair: { value: input.lbPair ?? null, isWritable: false },
              lbClmmProgram: { value: input.lbClmmProgram ?? null, isWritable: false },
              eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
              systemProgram: { value: input.systemProgram ?? null, isWritable: false },
              rent: { value: input.rent ?? null, isWritable: false },
          };
    const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;
  
      // Original args.
    const args = { ...input,  };
  
  
  // Resolve default values.
if (!accounts.systemProgram.value) {
accounts.systemProgram.value = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
}
if (!accounts.rent.value) {
accounts.rent.value = 'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
}





      const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
    const instruction = {accounts: [
                  getAccountMeta(accounts.authority),
                  getAccountMeta(accounts.globalConfig),
                  getAccountMeta(accounts.strategy),
                  getAccountMeta(accounts.position),
                  getAccountMeta(accounts.lbPair),
                  getAccountMeta(accounts.lbClmmProgram),
                  getAccountMeta(accounts.eventAuthority),
                  getAccountMeta(accounts.systemProgram),
                  getAccountMeta(accounts.rent),
                      ]      ,    programAddress,
          data: getInitializePositionInstructionDataEncoder().encode(args as InitializePositionInstructionDataArgs),
      } as InitializePositionInstruction<TProgramAddress, TAccountAuthority, TAccountGlobalConfig, TAccountStrategy, TAccountPosition, TAccountLbPair, TAccountLbClmmProgram, TAccountEventAuthority, TAccountSystemProgram, TAccountRent>;

      return instruction;
  }


export type ParsedInitializePositionInstruction<
  TProgram extends string = typeof MAIKER_CONTRACTS_PROGRAM_ADDRESS,
      TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
  > = {
  programAddress: Address<TProgram>;
      accounts: {
                      authority: TAccountMetas[0],
                      globalConfig: TAccountMetas[1],
                      strategy: TAccountMetas[2],
                      position: TAccountMetas[3],
                      lbPair: TAccountMetas[4],
                        /** The lb_clmm program */
                lbClmmProgram: TAccountMetas[5],
                      eventAuthority: TAccountMetas[6],
                      systemProgram: TAccountMetas[7],
                      rent: TAccountMetas[8],
          };
        data: InitializePositionInstructionData;
  };

export function parseInitializePositionInstruction<
  TProgram extends string,
      TAccountMetas extends readonly IAccountMeta[],
  >(
  instruction: IInstruction<TProgram>
          & IInstructionWithAccounts<TAccountMetas>
              & IInstructionWithData<Uint8Array>
    ): ParsedInitializePositionInstruction<TProgram , TAccountMetas> {
      if (instruction.accounts.length < 9) {
      // TODO: Coded error.
      throw new Error('Not enough accounts');
    }
    let accountIndex = 0;
    const getNextAccount = () => {
      const accountMeta = instruction.accounts![accountIndex]!;
      accountIndex += 1;
      return accountMeta;
    }
        return {
    programAddress: instruction.programAddress,
          accounts: {
                              authority: getNextAccount(),
                                        globalConfig: getNextAccount(),
                                        strategy: getNextAccount(),
                                        position: getNextAccount(),
                                        lbPair: getNextAccount(),
                                        lbClmmProgram: getNextAccount(),
                                        eventAuthority: getNextAccount(),
                                        systemProgram: getNextAccount(),
                                        rent: getNextAccount(),
                        },
              data: getInitializePositionInstructionDataDecoder().decode(instruction.data),
      };
}

