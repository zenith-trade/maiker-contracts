/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getI64Decoder, getI64Encoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';

export const PENDING_WITHDRAWAL_DISCRIMINATOR = new Uint8Array([61, 103, 179, 177, 148, 199, 63, 171]);

export function getPendingWithdrawalDiscriminatorBytes() { return fixEncoderSize(getBytesEncoder(), 8).encode(PENDING_WITHDRAWAL_DISCRIMINATOR); }


export type PendingWithdrawal = { discriminator: ReadonlyUint8Array; user: Address; strategy: Address; sharesAmount: bigint; fullSharesAmount: bigint; tokenAmount: bigint; initiationTimestamp: bigint; availableTimestamp: bigint; bump: number;  };

export type PendingWithdrawalArgs = { user: Address; strategy: Address; sharesAmount: number | bigint; fullSharesAmount: number | bigint; tokenAmount: number | bigint; initiationTimestamp: number | bigint; availableTimestamp: number | bigint; bump: number;  };




export function getPendingWithdrawalEncoder(): Encoder<PendingWithdrawalArgs> {
  return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)], ['user', getAddressEncoder()], ['strategy', getAddressEncoder()], ['sharesAmount', getU64Encoder()], ['fullSharesAmount', getU64Encoder()], ['tokenAmount', getU64Encoder()], ['initiationTimestamp', getI64Encoder()], ['availableTimestamp', getI64Encoder()], ['bump', getU8Encoder()]]), (value) => ({ ...value, discriminator: PENDING_WITHDRAWAL_DISCRIMINATOR }));
}



export function getPendingWithdrawalDecoder(): Decoder<PendingWithdrawal> {
  return getStructDecoder([['discriminator', fixDecoderSize(getBytesDecoder(), 8)], ['user', getAddressDecoder()], ['strategy', getAddressDecoder()], ['sharesAmount', getU64Decoder()], ['fullSharesAmount', getU64Decoder()], ['tokenAmount', getU64Decoder()], ['initiationTimestamp', getI64Decoder()], ['availableTimestamp', getI64Decoder()], ['bump', getU8Decoder()]]);
}




export function getPendingWithdrawalCodec(): Codec<PendingWithdrawalArgs, PendingWithdrawal> {
  return combineCodec(getPendingWithdrawalEncoder(), getPendingWithdrawalDecoder());
}

export function decodePendingWithdrawal<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<PendingWithdrawal, TAddress>;
export function decodePendingWithdrawal<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<PendingWithdrawal, TAddress>;
export function decodePendingWithdrawal<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<PendingWithdrawal, TAddress> | MaybeAccount<PendingWithdrawal, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getPendingWithdrawalDecoder());
}

export async function fetchPendingWithdrawal<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<PendingWithdrawal, TAddress>> {
  const maybeAccount = await fetchMaybePendingWithdrawal(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybePendingWithdrawal<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<PendingWithdrawal, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodePendingWithdrawal(maybeAccount);
}

export async function fetchAllPendingWithdrawal(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<PendingWithdrawal>[]> {
  const maybeAccounts = await fetchAllMaybePendingWithdrawal(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybePendingWithdrawal(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<PendingWithdrawal>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodePendingWithdrawal(maybeAccount));
}

export function getPendingWithdrawalSize(): number {
  return 113;
}


