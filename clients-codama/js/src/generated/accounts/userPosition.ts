/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';

export const USER_POSITION_DISCRIMINATOR = new Uint8Array([251, 248, 209, 245, 83, 234, 17, 27]);

export function getUserPositionDiscriminatorBytes() { return fixEncoderSize(getBytesEncoder(), 8).encode(USER_POSITION_DISCRIMINATOR); }


export type UserPosition = { discriminator: ReadonlyUint8Array; user: Address; strategy: Address; strategyShare: bigint; lastShareValue: bigint; lastUpdateSlot: bigint; bump: number;  };

export type UserPositionArgs = { user: Address; strategy: Address; strategyShare: number | bigint; lastShareValue: number | bigint; lastUpdateSlot: number | bigint; bump: number;  };




export function getUserPositionEncoder(): Encoder<UserPositionArgs> {
  return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)], ['user', getAddressEncoder()], ['strategy', getAddressEncoder()], ['strategyShare', getU64Encoder()], ['lastShareValue', getU64Encoder()], ['lastUpdateSlot', getU64Encoder()], ['bump', getU8Encoder()]]), (value) => ({ ...value, discriminator: USER_POSITION_DISCRIMINATOR }));
}



export function getUserPositionDecoder(): Decoder<UserPosition> {
  return getStructDecoder([['discriminator', fixDecoderSize(getBytesDecoder(), 8)], ['user', getAddressDecoder()], ['strategy', getAddressDecoder()], ['strategyShare', getU64Decoder()], ['lastShareValue', getU64Decoder()], ['lastUpdateSlot', getU64Decoder()], ['bump', getU8Decoder()]]);
}




export function getUserPositionCodec(): Codec<UserPositionArgs, UserPosition> {
  return combineCodec(getUserPositionEncoder(), getUserPositionDecoder());
}

export function decodeUserPosition<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<UserPosition, TAddress>;
export function decodeUserPosition<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<UserPosition, TAddress>;
export function decodeUserPosition<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<UserPosition, TAddress> | MaybeAccount<UserPosition, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getUserPositionDecoder());
}

export async function fetchUserPosition<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<UserPosition, TAddress>> {
  const maybeAccount = await fetchMaybeUserPosition(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeUserPosition<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<UserPosition, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeUserPosition(maybeAccount);
}

export async function fetchAllUserPosition(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<UserPosition>[]> {
  const maybeAccounts = await fetchAllMaybeUserPosition(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeUserPosition(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<UserPosition>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeUserPosition(maybeAccount));
}

export function getUserPositionSize(): number {
  return 97;
}


