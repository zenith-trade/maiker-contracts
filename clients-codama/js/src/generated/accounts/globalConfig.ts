/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU16Decoder, getU16Encoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, transformEncoder, type Account, type Address, type Codec, type Decoder, type EncodedAccount, type Encoder, type FetchAccountConfig, type FetchAccountsConfig, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';

export const GLOBAL_CONFIG_DISCRIMINATOR = new Uint8Array([149, 8, 156, 202, 160, 252, 176, 217]);

export function getGlobalConfigDiscriminatorBytes() { return fixEncoderSize(getBytesEncoder(), 8).encode(GLOBAL_CONFIG_DISCRIMINATOR); }


export type GlobalConfig = { discriminator: ReadonlyUint8Array; admin: Address; performanceFeeBps: number; withdrawalFeeBps: number; treasury: Address; withdrawalIntervalSeconds: bigint; bump: number;  };

export type GlobalConfigArgs = { admin: Address; performanceFeeBps: number; withdrawalFeeBps: number; treasury: Address; withdrawalIntervalSeconds: number | bigint; bump: number;  };




export function getGlobalConfigEncoder(): Encoder<GlobalConfigArgs> {
  return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)], ['admin', getAddressEncoder()], ['performanceFeeBps', getU16Encoder()], ['withdrawalFeeBps', getU16Encoder()], ['treasury', getAddressEncoder()], ['withdrawalIntervalSeconds', getU64Encoder()], ['bump', getU8Encoder()]]), (value) => ({ ...value, discriminator: GLOBAL_CONFIG_DISCRIMINATOR }));
}



export function getGlobalConfigDecoder(): Decoder<GlobalConfig> {
  return getStructDecoder([['discriminator', fixDecoderSize(getBytesDecoder(), 8)], ['admin', getAddressDecoder()], ['performanceFeeBps', getU16Decoder()], ['withdrawalFeeBps', getU16Decoder()], ['treasury', getAddressDecoder()], ['withdrawalIntervalSeconds', getU64Decoder()], ['bump', getU8Decoder()]]);
}




export function getGlobalConfigCodec(): Codec<GlobalConfigArgs, GlobalConfig> {
  return combineCodec(getGlobalConfigEncoder(), getGlobalConfigDecoder());
}

export function decodeGlobalConfig<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<GlobalConfig, TAddress>;
export function decodeGlobalConfig<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<GlobalConfig, TAddress>;
export function decodeGlobalConfig<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<GlobalConfig, TAddress> | MaybeAccount<GlobalConfig, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getGlobalConfigDecoder());
}

export async function fetchGlobalConfig<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<GlobalConfig, TAddress>> {
  const maybeAccount = await fetchMaybeGlobalConfig(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeGlobalConfig<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<GlobalConfig, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeGlobalConfig(maybeAccount);
}

export async function fetchAllGlobalConfig(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<GlobalConfig>[]> {
  const maybeAccounts = await fetchAllMaybeGlobalConfig(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeGlobalConfig(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<GlobalConfig>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeGlobalConfig(maybeAccount));
}

export function getGlobalConfigSize(): number {
  return 85;
}


