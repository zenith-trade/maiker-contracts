/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { containsBytes, fixEncoderSize, getBytesEncoder, type Address, type ReadonlyUint8Array } from '@solana/kit';
import { type ParsedAddLiquidityInstruction, type ParsedClaimFeeInstruction, type ParsedClaimFeesInstruction, type ParsedClosePositionInstruction, type ParsedCreateStrategyInstruction, type ParsedDepositInstruction, type ParsedGetPositionValueInstruction, type ParsedInitializeInstruction, type ParsedInitializePositionInstruction, type ParsedInitiateWithdrawalInstruction, type ParsedProcessWithdrawalInstruction, type ParsedRemoveLiquidityInstruction, type ParsedUpdateGlobalConfigInstruction } from '../instructions';


export const MAIKER_CONTRACTS_PROGRAM_ADDRESS = '' as Address<''>;

export enum MaikerContractsAccount { GlobalConfig, PendingWithdrawal, StrategyConfig, UserPosition }

export function identifyMaikerContractsAccount(account: { data: ReadonlyUint8Array } | ReadonlyUint8Array): MaikerContractsAccount {
const data = 'data' in account ? account.data : account;
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([149, 8, 156, 202, 160, 252, 176, 217])), 0)) { return MaikerContractsAccount.GlobalConfig;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([61, 103, 179, 177, 148, 199, 63, 171])), 0)) { return MaikerContractsAccount.PendingWithdrawal;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([103, 12, 123, 61, 47, 87, 129, 57])), 0)) { return MaikerContractsAccount.StrategyConfig;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([251, 248, 209, 245, 83, 234, 17, 27])), 0)) { return MaikerContractsAccount.UserPosition;; }
throw new Error("The provided account could not be identified as a maikerContracts account.")
}

export enum MaikerContractsInstruction { Initialize, CreateStrategy, Deposit, InitiateWithdrawal, ProcessWithdrawal, GetPositionValue, UpdateGlobalConfig, ClaimFees, AddLiquidity, RemoveLiquidity, ClaimFee, ClosePosition, InitializePosition }

export function identifyMaikerContractsInstruction(instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array): MaikerContractsInstruction {
const data = 'data' in instruction ? instruction.data : instruction;
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([175, 175, 109, 31, 13, 152, 155, 237])), 0)) { return MaikerContractsInstruction.Initialize;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([152, 160, 107, 148, 245, 190, 127, 224])), 0)) { return MaikerContractsInstruction.CreateStrategy;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([242, 35, 198, 137, 82, 225, 242, 182])), 0)) { return MaikerContractsInstruction.Deposit;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([69, 216, 131, 74, 114, 122, 38, 112])), 0)) { return MaikerContractsInstruction.InitiateWithdrawal;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([51, 97, 236, 17, 37, 33, 196, 64])), 0)) { return MaikerContractsInstruction.ProcessWithdrawal;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([176, 101, 36, 67, 215, 72, 215, 247])), 0)) { return MaikerContractsInstruction.GetPositionValue;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([164, 84, 130, 189, 111, 58, 250, 200])), 0)) { return MaikerContractsInstruction.UpdateGlobalConfig;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([82, 251, 233, 156, 12, 52, 184, 202])), 0)) { return MaikerContractsInstruction.ClaimFees;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([181, 157, 89, 67, 143, 182, 52, 72])), 0)) { return MaikerContractsInstruction.AddLiquidity;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([80, 85, 209, 72, 24, 206, 177, 108])), 0)) { return MaikerContractsInstruction.RemoveLiquidity;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([169, 32, 79, 137, 136, 232, 70, 137])), 0)) { return MaikerContractsInstruction.ClaimFee;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([123, 134, 81, 0, 49, 68, 98, 98])), 0)) { return MaikerContractsInstruction.ClosePosition;; }
if (containsBytes(data, fixEncoderSize(getBytesEncoder(), 8).encode(new Uint8Array([219, 192, 234, 71, 190, 191, 102, 80])), 0)) { return MaikerContractsInstruction.InitializePosition;; }
throw new Error("The provided instruction could not be identified as a maikerContracts instruction.")
}

export type ParsedMaikerContractsInstruction<TProgram extends string = ''> =
| { instructionType: MaikerContractsInstruction.Initialize } & ParsedInitializeInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.CreateStrategy } & ParsedCreateStrategyInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.Deposit } & ParsedDepositInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.InitiateWithdrawal } & ParsedInitiateWithdrawalInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.ProcessWithdrawal } & ParsedProcessWithdrawalInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.GetPositionValue } & ParsedGetPositionValueInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.UpdateGlobalConfig } & ParsedUpdateGlobalConfigInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.ClaimFees } & ParsedClaimFeesInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.AddLiquidity } & ParsedAddLiquidityInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.RemoveLiquidity } & ParsedRemoveLiquidityInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.ClaimFee } & ParsedClaimFeeInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.ClosePosition } & ParsedClosePositionInstruction<TProgram>
| { instructionType: MaikerContractsInstruction.InitializePosition } & ParsedInitializePositionInstruction<TProgram>

